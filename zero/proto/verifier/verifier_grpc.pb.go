// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.1
// - protoc             v6.33.4
// source: verifier/verifier.proto

package verifier

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	SolidityVerifier_VerifyMultiPart_FullMethodName         = "/smartContractVerifier.SolidityVerifier/VerifyMultiPart"
	SolidityVerifier_VerifyStandardJson_FullMethodName      = "/smartContractVerifier.SolidityVerifier/VerifyStandardJson"
	SolidityVerifier_BatchVerifyMultiPart_FullMethodName    = "/smartContractVerifier.SolidityVerifier/BatchVerifyMultiPart"
	SolidityVerifier_BatchVerifyStandardJson_FullMethodName = "/smartContractVerifier.SolidityVerifier/BatchVerifyStandardJson"
	SolidityVerifier_ListCompilerVersions_FullMethodName    = "/smartContractVerifier.SolidityVerifier/ListCompilerVersions"
	SolidityVerifier_LookupMethods_FullMethodName           = "/smartContractVerifier.SolidityVerifier/LookupMethods"
)

// SolidityVerifierClient is the client API for SolidityVerifier service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SolidityVerifierClient interface {
	VerifyMultiPart(ctx context.Context, in *VerifySolidityMultiPartRequest, opts ...grpc.CallOption) (*VerifyResponse, error)
	VerifyStandardJson(ctx context.Context, in *VerifySolidityStandardJsonRequest, opts ...grpc.CallOption) (*VerifyResponse, error)
	BatchVerifyMultiPart(ctx context.Context, in *BatchVerifySolidityMultiPartRequest, opts ...grpc.CallOption) (*BatchVerifyResponse, error)
	BatchVerifyStandardJson(ctx context.Context, in *BatchVerifySolidityStandardJsonRequest, opts ...grpc.CallOption) (*BatchVerifyResponse, error)
	ListCompilerVersions(ctx context.Context, in *ListCompilerVersionsRequest, opts ...grpc.CallOption) (*ListCompilerVersionsResponse, error)
	LookupMethods(ctx context.Context, in *LookupMethodsRequest, opts ...grpc.CallOption) (*LookupMethodsResponse, error)
}

type solidityVerifierClient struct {
	cc grpc.ClientConnInterface
}

func NewSolidityVerifierClient(cc grpc.ClientConnInterface) SolidityVerifierClient {
	return &solidityVerifierClient{cc}
}

func (c *solidityVerifierClient) VerifyMultiPart(ctx context.Context, in *VerifySolidityMultiPartRequest, opts ...grpc.CallOption) (*VerifyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerifyResponse)
	err := c.cc.Invoke(ctx, SolidityVerifier_VerifyMultiPart_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *solidityVerifierClient) VerifyStandardJson(ctx context.Context, in *VerifySolidityStandardJsonRequest, opts ...grpc.CallOption) (*VerifyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerifyResponse)
	err := c.cc.Invoke(ctx, SolidityVerifier_VerifyStandardJson_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *solidityVerifierClient) BatchVerifyMultiPart(ctx context.Context, in *BatchVerifySolidityMultiPartRequest, opts ...grpc.CallOption) (*BatchVerifyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BatchVerifyResponse)
	err := c.cc.Invoke(ctx, SolidityVerifier_BatchVerifyMultiPart_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *solidityVerifierClient) BatchVerifyStandardJson(ctx context.Context, in *BatchVerifySolidityStandardJsonRequest, opts ...grpc.CallOption) (*BatchVerifyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BatchVerifyResponse)
	err := c.cc.Invoke(ctx, SolidityVerifier_BatchVerifyStandardJson_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *solidityVerifierClient) ListCompilerVersions(ctx context.Context, in *ListCompilerVersionsRequest, opts ...grpc.CallOption) (*ListCompilerVersionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListCompilerVersionsResponse)
	err := c.cc.Invoke(ctx, SolidityVerifier_ListCompilerVersions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *solidityVerifierClient) LookupMethods(ctx context.Context, in *LookupMethodsRequest, opts ...grpc.CallOption) (*LookupMethodsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LookupMethodsResponse)
	err := c.cc.Invoke(ctx, SolidityVerifier_LookupMethods_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SolidityVerifierServer is the server API for SolidityVerifier service.
// All implementations must embed UnimplementedSolidityVerifierServer
// for forward compatibility.
type SolidityVerifierServer interface {
	VerifyMultiPart(context.Context, *VerifySolidityMultiPartRequest) (*VerifyResponse, error)
	VerifyStandardJson(context.Context, *VerifySolidityStandardJsonRequest) (*VerifyResponse, error)
	BatchVerifyMultiPart(context.Context, *BatchVerifySolidityMultiPartRequest) (*BatchVerifyResponse, error)
	BatchVerifyStandardJson(context.Context, *BatchVerifySolidityStandardJsonRequest) (*BatchVerifyResponse, error)
	ListCompilerVersions(context.Context, *ListCompilerVersionsRequest) (*ListCompilerVersionsResponse, error)
	LookupMethods(context.Context, *LookupMethodsRequest) (*LookupMethodsResponse, error)
	mustEmbedUnimplementedSolidityVerifierServer()
}

// UnimplementedSolidityVerifierServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSolidityVerifierServer struct{}

func (UnimplementedSolidityVerifierServer) VerifyMultiPart(context.Context, *VerifySolidityMultiPartRequest) (*VerifyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method VerifyMultiPart not implemented")
}
func (UnimplementedSolidityVerifierServer) VerifyStandardJson(context.Context, *VerifySolidityStandardJsonRequest) (*VerifyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method VerifyStandardJson not implemented")
}
func (UnimplementedSolidityVerifierServer) BatchVerifyMultiPart(context.Context, *BatchVerifySolidityMultiPartRequest) (*BatchVerifyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method BatchVerifyMultiPart not implemented")
}
func (UnimplementedSolidityVerifierServer) BatchVerifyStandardJson(context.Context, *BatchVerifySolidityStandardJsonRequest) (*BatchVerifyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method BatchVerifyStandardJson not implemented")
}
func (UnimplementedSolidityVerifierServer) ListCompilerVersions(context.Context, *ListCompilerVersionsRequest) (*ListCompilerVersionsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListCompilerVersions not implemented")
}
func (UnimplementedSolidityVerifierServer) LookupMethods(context.Context, *LookupMethodsRequest) (*LookupMethodsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method LookupMethods not implemented")
}
func (UnimplementedSolidityVerifierServer) mustEmbedUnimplementedSolidityVerifierServer() {}
func (UnimplementedSolidityVerifierServer) testEmbeddedByValue()                          {}

// UnsafeSolidityVerifierServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SolidityVerifierServer will
// result in compilation errors.
type UnsafeSolidityVerifierServer interface {
	mustEmbedUnimplementedSolidityVerifierServer()
}

func RegisterSolidityVerifierServer(s grpc.ServiceRegistrar, srv SolidityVerifierServer) {
	// If the following call panics, it indicates UnimplementedSolidityVerifierServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SolidityVerifier_ServiceDesc, srv)
}

func _SolidityVerifier_VerifyMultiPart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifySolidityMultiPartRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SolidityVerifierServer).VerifyMultiPart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SolidityVerifier_VerifyMultiPart_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SolidityVerifierServer).VerifyMultiPart(ctx, req.(*VerifySolidityMultiPartRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SolidityVerifier_VerifyStandardJson_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifySolidityStandardJsonRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SolidityVerifierServer).VerifyStandardJson(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SolidityVerifier_VerifyStandardJson_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SolidityVerifierServer).VerifyStandardJson(ctx, req.(*VerifySolidityStandardJsonRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SolidityVerifier_BatchVerifyMultiPart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchVerifySolidityMultiPartRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SolidityVerifierServer).BatchVerifyMultiPart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SolidityVerifier_BatchVerifyMultiPart_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SolidityVerifierServer).BatchVerifyMultiPart(ctx, req.(*BatchVerifySolidityMultiPartRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SolidityVerifier_BatchVerifyStandardJson_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchVerifySolidityStandardJsonRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SolidityVerifierServer).BatchVerifyStandardJson(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SolidityVerifier_BatchVerifyStandardJson_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SolidityVerifierServer).BatchVerifyStandardJson(ctx, req.(*BatchVerifySolidityStandardJsonRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SolidityVerifier_ListCompilerVersions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCompilerVersionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SolidityVerifierServer).ListCompilerVersions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SolidityVerifier_ListCompilerVersions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SolidityVerifierServer).ListCompilerVersions(ctx, req.(*ListCompilerVersionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SolidityVerifier_LookupMethods_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LookupMethodsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SolidityVerifierServer).LookupMethods(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SolidityVerifier_LookupMethods_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SolidityVerifierServer).LookupMethods(ctx, req.(*LookupMethodsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SolidityVerifier_ServiceDesc is the grpc.ServiceDesc for SolidityVerifier service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SolidityVerifier_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "smartContractVerifier.SolidityVerifier",
	HandlerType: (*SolidityVerifierServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "VerifyMultiPart",
			Handler:    _SolidityVerifier_VerifyMultiPart_Handler,
		},
		{
			MethodName: "VerifyStandardJson",
			Handler:    _SolidityVerifier_VerifyStandardJson_Handler,
		},
		{
			MethodName: "BatchVerifyMultiPart",
			Handler:    _SolidityVerifier_BatchVerifyMultiPart_Handler,
		},
		{
			MethodName: "BatchVerifyStandardJson",
			Handler:    _SolidityVerifier_BatchVerifyStandardJson_Handler,
		},
		{
			MethodName: "ListCompilerVersions",
			Handler:    _SolidityVerifier_ListCompilerVersions_Handler,
		},
		{
			MethodName: "LookupMethods",
			Handler:    _SolidityVerifier_LookupMethods_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "verifier/verifier.proto",
}

const (
	VyperVerifier_VerifyMultiPart_FullMethodName      = "/smartContractVerifier.VyperVerifier/VerifyMultiPart"
	VyperVerifier_VerifyStandardJson_FullMethodName   = "/smartContractVerifier.VyperVerifier/VerifyStandardJson"
	VyperVerifier_ListCompilerVersions_FullMethodName = "/smartContractVerifier.VyperVerifier/ListCompilerVersions"
)

// VyperVerifierClient is the client API for VyperVerifier service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VyperVerifierClient interface {
	VerifyMultiPart(ctx context.Context, in *VerifyVyperMultiPartRequest, opts ...grpc.CallOption) (*VerifyResponse, error)
	VerifyStandardJson(ctx context.Context, in *VerifyVyperStandardJsonRequest, opts ...grpc.CallOption) (*VerifyResponse, error)
	ListCompilerVersions(ctx context.Context, in *ListCompilerVersionsRequest, opts ...grpc.CallOption) (*ListCompilerVersionsResponse, error)
}

type vyperVerifierClient struct {
	cc grpc.ClientConnInterface
}

func NewVyperVerifierClient(cc grpc.ClientConnInterface) VyperVerifierClient {
	return &vyperVerifierClient{cc}
}

func (c *vyperVerifierClient) VerifyMultiPart(ctx context.Context, in *VerifyVyperMultiPartRequest, opts ...grpc.CallOption) (*VerifyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerifyResponse)
	err := c.cc.Invoke(ctx, VyperVerifier_VerifyMultiPart_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vyperVerifierClient) VerifyStandardJson(ctx context.Context, in *VerifyVyperStandardJsonRequest, opts ...grpc.CallOption) (*VerifyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerifyResponse)
	err := c.cc.Invoke(ctx, VyperVerifier_VerifyStandardJson_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vyperVerifierClient) ListCompilerVersions(ctx context.Context, in *ListCompilerVersionsRequest, opts ...grpc.CallOption) (*ListCompilerVersionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListCompilerVersionsResponse)
	err := c.cc.Invoke(ctx, VyperVerifier_ListCompilerVersions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VyperVerifierServer is the server API for VyperVerifier service.
// All implementations must embed UnimplementedVyperVerifierServer
// for forward compatibility.
type VyperVerifierServer interface {
	VerifyMultiPart(context.Context, *VerifyVyperMultiPartRequest) (*VerifyResponse, error)
	VerifyStandardJson(context.Context, *VerifyVyperStandardJsonRequest) (*VerifyResponse, error)
	ListCompilerVersions(context.Context, *ListCompilerVersionsRequest) (*ListCompilerVersionsResponse, error)
	mustEmbedUnimplementedVyperVerifierServer()
}

// UnimplementedVyperVerifierServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedVyperVerifierServer struct{}

func (UnimplementedVyperVerifierServer) VerifyMultiPart(context.Context, *VerifyVyperMultiPartRequest) (*VerifyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method VerifyMultiPart not implemented")
}
func (UnimplementedVyperVerifierServer) VerifyStandardJson(context.Context, *VerifyVyperStandardJsonRequest) (*VerifyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method VerifyStandardJson not implemented")
}
func (UnimplementedVyperVerifierServer) ListCompilerVersions(context.Context, *ListCompilerVersionsRequest) (*ListCompilerVersionsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListCompilerVersions not implemented")
}
func (UnimplementedVyperVerifierServer) mustEmbedUnimplementedVyperVerifierServer() {}
func (UnimplementedVyperVerifierServer) testEmbeddedByValue()                       {}

// UnsafeVyperVerifierServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VyperVerifierServer will
// result in compilation errors.
type UnsafeVyperVerifierServer interface {
	mustEmbedUnimplementedVyperVerifierServer()
}

func RegisterVyperVerifierServer(s grpc.ServiceRegistrar, srv VyperVerifierServer) {
	// If the following call panics, it indicates UnimplementedVyperVerifierServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&VyperVerifier_ServiceDesc, srv)
}

func _VyperVerifier_VerifyMultiPart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyVyperMultiPartRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VyperVerifierServer).VerifyMultiPart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VyperVerifier_VerifyMultiPart_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VyperVerifierServer).VerifyMultiPart(ctx, req.(*VerifyVyperMultiPartRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VyperVerifier_VerifyStandardJson_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyVyperStandardJsonRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VyperVerifierServer).VerifyStandardJson(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VyperVerifier_VerifyStandardJson_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VyperVerifierServer).VerifyStandardJson(ctx, req.(*VerifyVyperStandardJsonRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VyperVerifier_ListCompilerVersions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCompilerVersionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VyperVerifierServer).ListCompilerVersions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VyperVerifier_ListCompilerVersions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VyperVerifierServer).ListCompilerVersions(ctx, req.(*ListCompilerVersionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// VyperVerifier_ServiceDesc is the grpc.ServiceDesc for VyperVerifier service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VyperVerifier_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "smartContractVerifier.VyperVerifier",
	HandlerType: (*VyperVerifierServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "VerifyMultiPart",
			Handler:    _VyperVerifier_VerifyMultiPart_Handler,
		},
		{
			MethodName: "VerifyStandardJson",
			Handler:    _VyperVerifier_VerifyStandardJson_Handler,
		},
		{
			MethodName: "ListCompilerVersions",
			Handler:    _VyperVerifier_ListCompilerVersions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "verifier/verifier.proto",
}

const (
	SourcifyVerifier_Verify_FullMethodName              = "/smartContractVerifier.SourcifyVerifier/Verify"
	SourcifyVerifier_VerifyFromEtherscan_FullMethodName = "/smartContractVerifier.SourcifyVerifier/VerifyFromEtherscan"
)

// SourcifyVerifierClient is the client API for SourcifyVerifier service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SourcifyVerifierClient interface {
	Verify(ctx context.Context, in *VerifySourcifyRequest, opts ...grpc.CallOption) (*VerifyResponse, error)
	VerifyFromEtherscan(ctx context.Context, in *VerifyFromEtherscanSourcifyRequest, opts ...grpc.CallOption) (*VerifyResponse, error)
}

type sourcifyVerifierClient struct {
	cc grpc.ClientConnInterface
}

func NewSourcifyVerifierClient(cc grpc.ClientConnInterface) SourcifyVerifierClient {
	return &sourcifyVerifierClient{cc}
}

func (c *sourcifyVerifierClient) Verify(ctx context.Context, in *VerifySourcifyRequest, opts ...grpc.CallOption) (*VerifyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerifyResponse)
	err := c.cc.Invoke(ctx, SourcifyVerifier_Verify_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sourcifyVerifierClient) VerifyFromEtherscan(ctx context.Context, in *VerifyFromEtherscanSourcifyRequest, opts ...grpc.CallOption) (*VerifyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerifyResponse)
	err := c.cc.Invoke(ctx, SourcifyVerifier_VerifyFromEtherscan_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SourcifyVerifierServer is the server API for SourcifyVerifier service.
// All implementations must embed UnimplementedSourcifyVerifierServer
// for forward compatibility.
type SourcifyVerifierServer interface {
	Verify(context.Context, *VerifySourcifyRequest) (*VerifyResponse, error)
	VerifyFromEtherscan(context.Context, *VerifyFromEtherscanSourcifyRequest) (*VerifyResponse, error)
	mustEmbedUnimplementedSourcifyVerifierServer()
}

// UnimplementedSourcifyVerifierServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSourcifyVerifierServer struct{}

func (UnimplementedSourcifyVerifierServer) Verify(context.Context, *VerifySourcifyRequest) (*VerifyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Verify not implemented")
}
func (UnimplementedSourcifyVerifierServer) VerifyFromEtherscan(context.Context, *VerifyFromEtherscanSourcifyRequest) (*VerifyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method VerifyFromEtherscan not implemented")
}
func (UnimplementedSourcifyVerifierServer) mustEmbedUnimplementedSourcifyVerifierServer() {}
func (UnimplementedSourcifyVerifierServer) testEmbeddedByValue()                          {}

// UnsafeSourcifyVerifierServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SourcifyVerifierServer will
// result in compilation errors.
type UnsafeSourcifyVerifierServer interface {
	mustEmbedUnimplementedSourcifyVerifierServer()
}

func RegisterSourcifyVerifierServer(s grpc.ServiceRegistrar, srv SourcifyVerifierServer) {
	// If the following call panics, it indicates UnimplementedSourcifyVerifierServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SourcifyVerifier_ServiceDesc, srv)
}

func _SourcifyVerifier_Verify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifySourcifyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SourcifyVerifierServer).Verify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SourcifyVerifier_Verify_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SourcifyVerifierServer).Verify(ctx, req.(*VerifySourcifyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SourcifyVerifier_VerifyFromEtherscan_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyFromEtherscanSourcifyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SourcifyVerifierServer).VerifyFromEtherscan(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SourcifyVerifier_VerifyFromEtherscan_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SourcifyVerifierServer).VerifyFromEtherscan(ctx, req.(*VerifyFromEtherscanSourcifyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SourcifyVerifier_ServiceDesc is the grpc.ServiceDesc for SourcifyVerifier service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SourcifyVerifier_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "smartContractVerifier.SourcifyVerifier",
	HandlerType: (*SourcifyVerifierServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Verify",
			Handler:    _SourcifyVerifier_Verify_Handler,
		},
		{
			MethodName: "VerifyFromEtherscan",
			Handler:    _SourcifyVerifier_VerifyFromEtherscan_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "verifier/verifier.proto",
}
