// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.1
// - protoc             v6.33.4
// source: bytecodedb/bytecodedb.proto

package bytecodedb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Database_SearchSources_FullMethodName                = "/ethBytecodeDb.Database/SearchSources"
	Database_SearchSourcifySources_FullMethodName        = "/ethBytecodeDb.Database/SearchSourcifySources"
	Database_SearchAllianceSources_FullMethodName        = "/ethBytecodeDb.Database/SearchAllianceSources"
	Database_SearchAllSources_FullMethodName             = "/ethBytecodeDb.Database/SearchAllSources"
	Database_SearchEventDescriptions_FullMethodName      = "/ethBytecodeDb.Database/SearchEventDescriptions"
	Database_BatchSearchEventDescriptions_FullMethodName = "/ethBytecodeDb.Database/BatchSearchEventDescriptions"
	Database_GetAllianceStats_FullMethodName             = "/ethBytecodeDb.Database/GetAllianceStats"
)

// DatabaseClient is the client API for Database service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DatabaseClient interface {
	SearchSources(ctx context.Context, in *SearchSourcesRequest, opts ...grpc.CallOption) (*SearchSourcesResponse, error)
	SearchSourcifySources(ctx context.Context, in *SearchSourcifySourcesRequest, opts ...grpc.CallOption) (*SearchSourcesResponse, error)
	SearchAllianceSources(ctx context.Context, in *SearchAllianceSourcesRequest, opts ...grpc.CallOption) (*SearchSourcesResponse, error)
	SearchAllSources(ctx context.Context, in *SearchAllSourcesRequest, opts ...grpc.CallOption) (*SearchAllSourcesResponse, error)
	SearchEventDescriptions(ctx context.Context, in *SearchEventDescriptionsRequest, opts ...grpc.CallOption) (*SearchEventDescriptionsResponse, error)
	BatchSearchEventDescriptions(ctx context.Context, in *BatchSearchEventDescriptionsRequest, opts ...grpc.CallOption) (*BatchSearchEventDescriptionsResponse, error)
	GetAllianceStats(ctx context.Context, in *GetAllianceStatsRequest, opts ...grpc.CallOption) (*AllianceStats, error)
}

type databaseClient struct {
	cc grpc.ClientConnInterface
}

func NewDatabaseClient(cc grpc.ClientConnInterface) DatabaseClient {
	return &databaseClient{cc}
}

func (c *databaseClient) SearchSources(ctx context.Context, in *SearchSourcesRequest, opts ...grpc.CallOption) (*SearchSourcesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SearchSourcesResponse)
	err := c.cc.Invoke(ctx, Database_SearchSources_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *databaseClient) SearchSourcifySources(ctx context.Context, in *SearchSourcifySourcesRequest, opts ...grpc.CallOption) (*SearchSourcesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SearchSourcesResponse)
	err := c.cc.Invoke(ctx, Database_SearchSourcifySources_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *databaseClient) SearchAllianceSources(ctx context.Context, in *SearchAllianceSourcesRequest, opts ...grpc.CallOption) (*SearchSourcesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SearchSourcesResponse)
	err := c.cc.Invoke(ctx, Database_SearchAllianceSources_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *databaseClient) SearchAllSources(ctx context.Context, in *SearchAllSourcesRequest, opts ...grpc.CallOption) (*SearchAllSourcesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SearchAllSourcesResponse)
	err := c.cc.Invoke(ctx, Database_SearchAllSources_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *databaseClient) SearchEventDescriptions(ctx context.Context, in *SearchEventDescriptionsRequest, opts ...grpc.CallOption) (*SearchEventDescriptionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SearchEventDescriptionsResponse)
	err := c.cc.Invoke(ctx, Database_SearchEventDescriptions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *databaseClient) BatchSearchEventDescriptions(ctx context.Context, in *BatchSearchEventDescriptionsRequest, opts ...grpc.CallOption) (*BatchSearchEventDescriptionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BatchSearchEventDescriptionsResponse)
	err := c.cc.Invoke(ctx, Database_BatchSearchEventDescriptions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *databaseClient) GetAllianceStats(ctx context.Context, in *GetAllianceStatsRequest, opts ...grpc.CallOption) (*AllianceStats, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AllianceStats)
	err := c.cc.Invoke(ctx, Database_GetAllianceStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DatabaseServer is the server API for Database service.
// All implementations must embed UnimplementedDatabaseServer
// for forward compatibility.
type DatabaseServer interface {
	SearchSources(context.Context, *SearchSourcesRequest) (*SearchSourcesResponse, error)
	SearchSourcifySources(context.Context, *SearchSourcifySourcesRequest) (*SearchSourcesResponse, error)
	SearchAllianceSources(context.Context, *SearchAllianceSourcesRequest) (*SearchSourcesResponse, error)
	SearchAllSources(context.Context, *SearchAllSourcesRequest) (*SearchAllSourcesResponse, error)
	SearchEventDescriptions(context.Context, *SearchEventDescriptionsRequest) (*SearchEventDescriptionsResponse, error)
	BatchSearchEventDescriptions(context.Context, *BatchSearchEventDescriptionsRequest) (*BatchSearchEventDescriptionsResponse, error)
	GetAllianceStats(context.Context, *GetAllianceStatsRequest) (*AllianceStats, error)
	mustEmbedUnimplementedDatabaseServer()
}

// UnimplementedDatabaseServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedDatabaseServer struct{}

func (UnimplementedDatabaseServer) SearchSources(context.Context, *SearchSourcesRequest) (*SearchSourcesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SearchSources not implemented")
}
func (UnimplementedDatabaseServer) SearchSourcifySources(context.Context, *SearchSourcifySourcesRequest) (*SearchSourcesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SearchSourcifySources not implemented")
}
func (UnimplementedDatabaseServer) SearchAllianceSources(context.Context, *SearchAllianceSourcesRequest) (*SearchSourcesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SearchAllianceSources not implemented")
}
func (UnimplementedDatabaseServer) SearchAllSources(context.Context, *SearchAllSourcesRequest) (*SearchAllSourcesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SearchAllSources not implemented")
}
func (UnimplementedDatabaseServer) SearchEventDescriptions(context.Context, *SearchEventDescriptionsRequest) (*SearchEventDescriptionsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SearchEventDescriptions not implemented")
}
func (UnimplementedDatabaseServer) BatchSearchEventDescriptions(context.Context, *BatchSearchEventDescriptionsRequest) (*BatchSearchEventDescriptionsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method BatchSearchEventDescriptions not implemented")
}
func (UnimplementedDatabaseServer) GetAllianceStats(context.Context, *GetAllianceStatsRequest) (*AllianceStats, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAllianceStats not implemented")
}
func (UnimplementedDatabaseServer) mustEmbedUnimplementedDatabaseServer() {}
func (UnimplementedDatabaseServer) testEmbeddedByValue()                  {}

// UnsafeDatabaseServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DatabaseServer will
// result in compilation errors.
type UnsafeDatabaseServer interface {
	mustEmbedUnimplementedDatabaseServer()
}

func RegisterDatabaseServer(s grpc.ServiceRegistrar, srv DatabaseServer) {
	// If the following call panics, it indicates UnimplementedDatabaseServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Database_ServiceDesc, srv)
}

func _Database_SearchSources_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchSourcesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DatabaseServer).SearchSources(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Database_SearchSources_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DatabaseServer).SearchSources(ctx, req.(*SearchSourcesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Database_SearchSourcifySources_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchSourcifySourcesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DatabaseServer).SearchSourcifySources(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Database_SearchSourcifySources_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DatabaseServer).SearchSourcifySources(ctx, req.(*SearchSourcifySourcesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Database_SearchAllianceSources_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchAllianceSourcesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DatabaseServer).SearchAllianceSources(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Database_SearchAllianceSources_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DatabaseServer).SearchAllianceSources(ctx, req.(*SearchAllianceSourcesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Database_SearchAllSources_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchAllSourcesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DatabaseServer).SearchAllSources(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Database_SearchAllSources_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DatabaseServer).SearchAllSources(ctx, req.(*SearchAllSourcesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Database_SearchEventDescriptions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchEventDescriptionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DatabaseServer).SearchEventDescriptions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Database_SearchEventDescriptions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DatabaseServer).SearchEventDescriptions(ctx, req.(*SearchEventDescriptionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Database_BatchSearchEventDescriptions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchSearchEventDescriptionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DatabaseServer).BatchSearchEventDescriptions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Database_BatchSearchEventDescriptions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DatabaseServer).BatchSearchEventDescriptions(ctx, req.(*BatchSearchEventDescriptionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Database_GetAllianceStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllianceStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DatabaseServer).GetAllianceStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Database_GetAllianceStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DatabaseServer).GetAllianceStats(ctx, req.(*GetAllianceStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Database_ServiceDesc is the grpc.ServiceDesc for Database service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Database_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ethBytecodeDb.Database",
	HandlerType: (*DatabaseServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SearchSources",
			Handler:    _Database_SearchSources_Handler,
		},
		{
			MethodName: "SearchSourcifySources",
			Handler:    _Database_SearchSourcifySources_Handler,
		},
		{
			MethodName: "SearchAllianceSources",
			Handler:    _Database_SearchAllianceSources_Handler,
		},
		{
			MethodName: "SearchAllSources",
			Handler:    _Database_SearchAllSources_Handler,
		},
		{
			MethodName: "SearchEventDescriptions",
			Handler:    _Database_SearchEventDescriptions_Handler,
		},
		{
			MethodName: "BatchSearchEventDescriptions",
			Handler:    _Database_BatchSearchEventDescriptions_Handler,
		},
		{
			MethodName: "GetAllianceStats",
			Handler:    _Database_GetAllianceStats_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "bytecodedb/bytecodedb.proto",
}

const (
	SolidityVerifier_VerifyMultiPart_FullMethodName      = "/ethBytecodeDb.SolidityVerifier/VerifyMultiPart"
	SolidityVerifier_VerifyStandardJson_FullMethodName   = "/ethBytecodeDb.SolidityVerifier/VerifyStandardJson"
	SolidityVerifier_ListCompilerVersions_FullMethodName = "/ethBytecodeDb.SolidityVerifier/ListCompilerVersions"
)

// SolidityVerifierClient is the client API for SolidityVerifier service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SolidityVerifierClient interface {
	VerifyMultiPart(ctx context.Context, in *VerifySolidityMultiPartRequest, opts ...grpc.CallOption) (*VerifyResponse, error)
	VerifyStandardJson(ctx context.Context, in *VerifySolidityStandardJsonRequest, opts ...grpc.CallOption) (*VerifyResponse, error)
	ListCompilerVersions(ctx context.Context, in *ListCompilerVersionsRequest, opts ...grpc.CallOption) (*ListCompilerVersionsResponse, error)
}

type solidityVerifierClient struct {
	cc grpc.ClientConnInterface
}

func NewSolidityVerifierClient(cc grpc.ClientConnInterface) SolidityVerifierClient {
	return &solidityVerifierClient{cc}
}

func (c *solidityVerifierClient) VerifyMultiPart(ctx context.Context, in *VerifySolidityMultiPartRequest, opts ...grpc.CallOption) (*VerifyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerifyResponse)
	err := c.cc.Invoke(ctx, SolidityVerifier_VerifyMultiPart_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *solidityVerifierClient) VerifyStandardJson(ctx context.Context, in *VerifySolidityStandardJsonRequest, opts ...grpc.CallOption) (*VerifyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerifyResponse)
	err := c.cc.Invoke(ctx, SolidityVerifier_VerifyStandardJson_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *solidityVerifierClient) ListCompilerVersions(ctx context.Context, in *ListCompilerVersionsRequest, opts ...grpc.CallOption) (*ListCompilerVersionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListCompilerVersionsResponse)
	err := c.cc.Invoke(ctx, SolidityVerifier_ListCompilerVersions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SolidityVerifierServer is the server API for SolidityVerifier service.
// All implementations must embed UnimplementedSolidityVerifierServer
// for forward compatibility.
type SolidityVerifierServer interface {
	VerifyMultiPart(context.Context, *VerifySolidityMultiPartRequest) (*VerifyResponse, error)
	VerifyStandardJson(context.Context, *VerifySolidityStandardJsonRequest) (*VerifyResponse, error)
	ListCompilerVersions(context.Context, *ListCompilerVersionsRequest) (*ListCompilerVersionsResponse, error)
	mustEmbedUnimplementedSolidityVerifierServer()
}

// UnimplementedSolidityVerifierServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSolidityVerifierServer struct{}

func (UnimplementedSolidityVerifierServer) VerifyMultiPart(context.Context, *VerifySolidityMultiPartRequest) (*VerifyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method VerifyMultiPart not implemented")
}
func (UnimplementedSolidityVerifierServer) VerifyStandardJson(context.Context, *VerifySolidityStandardJsonRequest) (*VerifyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method VerifyStandardJson not implemented")
}
func (UnimplementedSolidityVerifierServer) ListCompilerVersions(context.Context, *ListCompilerVersionsRequest) (*ListCompilerVersionsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListCompilerVersions not implemented")
}
func (UnimplementedSolidityVerifierServer) mustEmbedUnimplementedSolidityVerifierServer() {}
func (UnimplementedSolidityVerifierServer) testEmbeddedByValue()                          {}

// UnsafeSolidityVerifierServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SolidityVerifierServer will
// result in compilation errors.
type UnsafeSolidityVerifierServer interface {
	mustEmbedUnimplementedSolidityVerifierServer()
}

func RegisterSolidityVerifierServer(s grpc.ServiceRegistrar, srv SolidityVerifierServer) {
	// If the following call panics, it indicates UnimplementedSolidityVerifierServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SolidityVerifier_ServiceDesc, srv)
}

func _SolidityVerifier_VerifyMultiPart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifySolidityMultiPartRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SolidityVerifierServer).VerifyMultiPart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SolidityVerifier_VerifyMultiPart_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SolidityVerifierServer).VerifyMultiPart(ctx, req.(*VerifySolidityMultiPartRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SolidityVerifier_VerifyStandardJson_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifySolidityStandardJsonRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SolidityVerifierServer).VerifyStandardJson(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SolidityVerifier_VerifyStandardJson_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SolidityVerifierServer).VerifyStandardJson(ctx, req.(*VerifySolidityStandardJsonRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SolidityVerifier_ListCompilerVersions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCompilerVersionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SolidityVerifierServer).ListCompilerVersions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SolidityVerifier_ListCompilerVersions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SolidityVerifierServer).ListCompilerVersions(ctx, req.(*ListCompilerVersionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SolidityVerifier_ServiceDesc is the grpc.ServiceDesc for SolidityVerifier service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SolidityVerifier_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ethBytecodeDb.SolidityVerifier",
	HandlerType: (*SolidityVerifierServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "VerifyMultiPart",
			Handler:    _SolidityVerifier_VerifyMultiPart_Handler,
		},
		{
			MethodName: "VerifyStandardJson",
			Handler:    _SolidityVerifier_VerifyStandardJson_Handler,
		},
		{
			MethodName: "ListCompilerVersions",
			Handler:    _SolidityVerifier_ListCompilerVersions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "bytecodedb/bytecodedb.proto",
}

const (
	VyperVerifier_VerifyMultiPart_FullMethodName      = "/ethBytecodeDb.VyperVerifier/VerifyMultiPart"
	VyperVerifier_VerifyStandardJson_FullMethodName   = "/ethBytecodeDb.VyperVerifier/VerifyStandardJson"
	VyperVerifier_ListCompilerVersions_FullMethodName = "/ethBytecodeDb.VyperVerifier/ListCompilerVersions"
)

// VyperVerifierClient is the client API for VyperVerifier service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VyperVerifierClient interface {
	VerifyMultiPart(ctx context.Context, in *VerifyVyperMultiPartRequest, opts ...grpc.CallOption) (*VerifyResponse, error)
	VerifyStandardJson(ctx context.Context, in *VerifyVyperStandardJsonRequest, opts ...grpc.CallOption) (*VerifyResponse, error)
	ListCompilerVersions(ctx context.Context, in *ListCompilerVersionsRequest, opts ...grpc.CallOption) (*ListCompilerVersionsResponse, error)
}

type vyperVerifierClient struct {
	cc grpc.ClientConnInterface
}

func NewVyperVerifierClient(cc grpc.ClientConnInterface) VyperVerifierClient {
	return &vyperVerifierClient{cc}
}

func (c *vyperVerifierClient) VerifyMultiPart(ctx context.Context, in *VerifyVyperMultiPartRequest, opts ...grpc.CallOption) (*VerifyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerifyResponse)
	err := c.cc.Invoke(ctx, VyperVerifier_VerifyMultiPart_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vyperVerifierClient) VerifyStandardJson(ctx context.Context, in *VerifyVyperStandardJsonRequest, opts ...grpc.CallOption) (*VerifyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerifyResponse)
	err := c.cc.Invoke(ctx, VyperVerifier_VerifyStandardJson_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vyperVerifierClient) ListCompilerVersions(ctx context.Context, in *ListCompilerVersionsRequest, opts ...grpc.CallOption) (*ListCompilerVersionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListCompilerVersionsResponse)
	err := c.cc.Invoke(ctx, VyperVerifier_ListCompilerVersions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VyperVerifierServer is the server API for VyperVerifier service.
// All implementations must embed UnimplementedVyperVerifierServer
// for forward compatibility.
type VyperVerifierServer interface {
	VerifyMultiPart(context.Context, *VerifyVyperMultiPartRequest) (*VerifyResponse, error)
	VerifyStandardJson(context.Context, *VerifyVyperStandardJsonRequest) (*VerifyResponse, error)
	ListCompilerVersions(context.Context, *ListCompilerVersionsRequest) (*ListCompilerVersionsResponse, error)
	mustEmbedUnimplementedVyperVerifierServer()
}

// UnimplementedVyperVerifierServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedVyperVerifierServer struct{}

func (UnimplementedVyperVerifierServer) VerifyMultiPart(context.Context, *VerifyVyperMultiPartRequest) (*VerifyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method VerifyMultiPart not implemented")
}
func (UnimplementedVyperVerifierServer) VerifyStandardJson(context.Context, *VerifyVyperStandardJsonRequest) (*VerifyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method VerifyStandardJson not implemented")
}
func (UnimplementedVyperVerifierServer) ListCompilerVersions(context.Context, *ListCompilerVersionsRequest) (*ListCompilerVersionsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListCompilerVersions not implemented")
}
func (UnimplementedVyperVerifierServer) mustEmbedUnimplementedVyperVerifierServer() {}
func (UnimplementedVyperVerifierServer) testEmbeddedByValue()                       {}

// UnsafeVyperVerifierServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VyperVerifierServer will
// result in compilation errors.
type UnsafeVyperVerifierServer interface {
	mustEmbedUnimplementedVyperVerifierServer()
}

func RegisterVyperVerifierServer(s grpc.ServiceRegistrar, srv VyperVerifierServer) {
	// If the following call panics, it indicates UnimplementedVyperVerifierServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&VyperVerifier_ServiceDesc, srv)
}

func _VyperVerifier_VerifyMultiPart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyVyperMultiPartRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VyperVerifierServer).VerifyMultiPart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VyperVerifier_VerifyMultiPart_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VyperVerifierServer).VerifyMultiPart(ctx, req.(*VerifyVyperMultiPartRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VyperVerifier_VerifyStandardJson_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyVyperStandardJsonRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VyperVerifierServer).VerifyStandardJson(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VyperVerifier_VerifyStandardJson_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VyperVerifierServer).VerifyStandardJson(ctx, req.(*VerifyVyperStandardJsonRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VyperVerifier_ListCompilerVersions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCompilerVersionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VyperVerifierServer).ListCompilerVersions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VyperVerifier_ListCompilerVersions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VyperVerifierServer).ListCompilerVersions(ctx, req.(*ListCompilerVersionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// VyperVerifier_ServiceDesc is the grpc.ServiceDesc for VyperVerifier service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VyperVerifier_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ethBytecodeDb.VyperVerifier",
	HandlerType: (*VyperVerifierServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "VerifyMultiPart",
			Handler:    _VyperVerifier_VerifyMultiPart_Handler,
		},
		{
			MethodName: "VerifyStandardJson",
			Handler:    _VyperVerifier_VerifyStandardJson_Handler,
		},
		{
			MethodName: "ListCompilerVersions",
			Handler:    _VyperVerifier_ListCompilerVersions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "bytecodedb/bytecodedb.proto",
}

const (
	SourcifyVerifier_Verify_FullMethodName              = "/ethBytecodeDb.SourcifyVerifier/Verify"
	SourcifyVerifier_VerifyFromEtherscan_FullMethodName = "/ethBytecodeDb.SourcifyVerifier/VerifyFromEtherscan"
)

// SourcifyVerifierClient is the client API for SourcifyVerifier service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SourcifyVerifierClient interface {
	Verify(ctx context.Context, in *VerifySourcifyRequest, opts ...grpc.CallOption) (*VerifyResponse, error)
	VerifyFromEtherscan(ctx context.Context, in *VerifyFromEtherscanSourcifyRequest, opts ...grpc.CallOption) (*VerifyResponse, error)
}

type sourcifyVerifierClient struct {
	cc grpc.ClientConnInterface
}

func NewSourcifyVerifierClient(cc grpc.ClientConnInterface) SourcifyVerifierClient {
	return &sourcifyVerifierClient{cc}
}

func (c *sourcifyVerifierClient) Verify(ctx context.Context, in *VerifySourcifyRequest, opts ...grpc.CallOption) (*VerifyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerifyResponse)
	err := c.cc.Invoke(ctx, SourcifyVerifier_Verify_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sourcifyVerifierClient) VerifyFromEtherscan(ctx context.Context, in *VerifyFromEtherscanSourcifyRequest, opts ...grpc.CallOption) (*VerifyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerifyResponse)
	err := c.cc.Invoke(ctx, SourcifyVerifier_VerifyFromEtherscan_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SourcifyVerifierServer is the server API for SourcifyVerifier service.
// All implementations must embed UnimplementedSourcifyVerifierServer
// for forward compatibility.
type SourcifyVerifierServer interface {
	Verify(context.Context, *VerifySourcifyRequest) (*VerifyResponse, error)
	VerifyFromEtherscan(context.Context, *VerifyFromEtherscanSourcifyRequest) (*VerifyResponse, error)
	mustEmbedUnimplementedSourcifyVerifierServer()
}

// UnimplementedSourcifyVerifierServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSourcifyVerifierServer struct{}

func (UnimplementedSourcifyVerifierServer) Verify(context.Context, *VerifySourcifyRequest) (*VerifyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Verify not implemented")
}
func (UnimplementedSourcifyVerifierServer) VerifyFromEtherscan(context.Context, *VerifyFromEtherscanSourcifyRequest) (*VerifyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method VerifyFromEtherscan not implemented")
}
func (UnimplementedSourcifyVerifierServer) mustEmbedUnimplementedSourcifyVerifierServer() {}
func (UnimplementedSourcifyVerifierServer) testEmbeddedByValue()                          {}

// UnsafeSourcifyVerifierServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SourcifyVerifierServer will
// result in compilation errors.
type UnsafeSourcifyVerifierServer interface {
	mustEmbedUnimplementedSourcifyVerifierServer()
}

func RegisterSourcifyVerifierServer(s grpc.ServiceRegistrar, srv SourcifyVerifierServer) {
	// If the following call panics, it indicates UnimplementedSourcifyVerifierServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SourcifyVerifier_ServiceDesc, srv)
}

func _SourcifyVerifier_Verify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifySourcifyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SourcifyVerifierServer).Verify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SourcifyVerifier_Verify_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SourcifyVerifierServer).Verify(ctx, req.(*VerifySourcifyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SourcifyVerifier_VerifyFromEtherscan_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyFromEtherscanSourcifyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SourcifyVerifierServer).VerifyFromEtherscan(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SourcifyVerifier_VerifyFromEtherscan_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SourcifyVerifierServer).VerifyFromEtherscan(ctx, req.(*VerifyFromEtherscanSourcifyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SourcifyVerifier_ServiceDesc is the grpc.ServiceDesc for SourcifyVerifier service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SourcifyVerifier_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ethBytecodeDb.SourcifyVerifier",
	HandlerType: (*SourcifyVerifierServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Verify",
			Handler:    _SourcifyVerifier_Verify_Handler,
		},
		{
			MethodName: "VerifyFromEtherscan",
			Handler:    _SourcifyVerifier_VerifyFromEtherscan_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "bytecodedb/bytecodedb.proto",
}

const (
	VerifierAlliance_BatchImportSolidityMultiPart_FullMethodName    = "/ethBytecodeDb.VerifierAlliance/BatchImportSolidityMultiPart"
	VerifierAlliance_BatchImportSolidityStandardJson_FullMethodName = "/ethBytecodeDb.VerifierAlliance/BatchImportSolidityStandardJson"
)

// VerifierAllianceClient is the client API for VerifierAlliance service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VerifierAllianceClient interface {
	BatchImportSolidityMultiPart(ctx context.Context, in *VerifierAllianceBatchImportSolidityMultiPartRequest, opts ...grpc.CallOption) (*VerifierAllianceBatchImportResponse, error)
	BatchImportSolidityStandardJson(ctx context.Context, in *VerifierAllianceBatchImportSolidityStandardJsonRequest, opts ...grpc.CallOption) (*VerifierAllianceBatchImportResponse, error)
}

type verifierAllianceClient struct {
	cc grpc.ClientConnInterface
}

func NewVerifierAllianceClient(cc grpc.ClientConnInterface) VerifierAllianceClient {
	return &verifierAllianceClient{cc}
}

func (c *verifierAllianceClient) BatchImportSolidityMultiPart(ctx context.Context, in *VerifierAllianceBatchImportSolidityMultiPartRequest, opts ...grpc.CallOption) (*VerifierAllianceBatchImportResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerifierAllianceBatchImportResponse)
	err := c.cc.Invoke(ctx, VerifierAlliance_BatchImportSolidityMultiPart_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *verifierAllianceClient) BatchImportSolidityStandardJson(ctx context.Context, in *VerifierAllianceBatchImportSolidityStandardJsonRequest, opts ...grpc.CallOption) (*VerifierAllianceBatchImportResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerifierAllianceBatchImportResponse)
	err := c.cc.Invoke(ctx, VerifierAlliance_BatchImportSolidityStandardJson_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VerifierAllianceServer is the server API for VerifierAlliance service.
// All implementations must embed UnimplementedVerifierAllianceServer
// for forward compatibility.
type VerifierAllianceServer interface {
	BatchImportSolidityMultiPart(context.Context, *VerifierAllianceBatchImportSolidityMultiPartRequest) (*VerifierAllianceBatchImportResponse, error)
	BatchImportSolidityStandardJson(context.Context, *VerifierAllianceBatchImportSolidityStandardJsonRequest) (*VerifierAllianceBatchImportResponse, error)
	mustEmbedUnimplementedVerifierAllianceServer()
}

// UnimplementedVerifierAllianceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedVerifierAllianceServer struct{}

func (UnimplementedVerifierAllianceServer) BatchImportSolidityMultiPart(context.Context, *VerifierAllianceBatchImportSolidityMultiPartRequest) (*VerifierAllianceBatchImportResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method BatchImportSolidityMultiPart not implemented")
}
func (UnimplementedVerifierAllianceServer) BatchImportSolidityStandardJson(context.Context, *VerifierAllianceBatchImportSolidityStandardJsonRequest) (*VerifierAllianceBatchImportResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method BatchImportSolidityStandardJson not implemented")
}
func (UnimplementedVerifierAllianceServer) mustEmbedUnimplementedVerifierAllianceServer() {}
func (UnimplementedVerifierAllianceServer) testEmbeddedByValue()                          {}

// UnsafeVerifierAllianceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VerifierAllianceServer will
// result in compilation errors.
type UnsafeVerifierAllianceServer interface {
	mustEmbedUnimplementedVerifierAllianceServer()
}

func RegisterVerifierAllianceServer(s grpc.ServiceRegistrar, srv VerifierAllianceServer) {
	// If the following call panics, it indicates UnimplementedVerifierAllianceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&VerifierAlliance_ServiceDesc, srv)
}

func _VerifierAlliance_BatchImportSolidityMultiPart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifierAllianceBatchImportSolidityMultiPartRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VerifierAllianceServer).BatchImportSolidityMultiPart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VerifierAlliance_BatchImportSolidityMultiPart_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VerifierAllianceServer).BatchImportSolidityMultiPart(ctx, req.(*VerifierAllianceBatchImportSolidityMultiPartRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VerifierAlliance_BatchImportSolidityStandardJson_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifierAllianceBatchImportSolidityStandardJsonRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VerifierAllianceServer).BatchImportSolidityStandardJson(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VerifierAlliance_BatchImportSolidityStandardJson_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VerifierAllianceServer).BatchImportSolidityStandardJson(ctx, req.(*VerifierAllianceBatchImportSolidityStandardJsonRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// VerifierAlliance_ServiceDesc is the grpc.ServiceDesc for VerifierAlliance service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VerifierAlliance_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ethBytecodeDb.VerifierAlliance",
	HandlerType: (*VerifierAllianceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "BatchImportSolidityMultiPart",
			Handler:    _VerifierAlliance_BatchImportSolidityMultiPart_Handler,
		},
		{
			MethodName: "BatchImportSolidityStandardJson",
			Handler:    _VerifierAlliance_BatchImportSolidityStandardJson_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "bytecodedb/bytecodedb.proto",
}
